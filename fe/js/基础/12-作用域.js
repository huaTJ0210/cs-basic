/**
 * + 作用域：变量起作用的范围，在变量及函数定义时就已确认，与运行时无关
 * + 作用域链：定义的作用域之间存在包含关系，从底往上查询就构成了一条作用域链
 * + 执行上下文：函数运行时创建的一个对象，
 *    内部存储着函数的变量对象及作用域链上的其他作用域的变量对象
 *  + 变量对象：存储当前作用域声明的变量便于运行时查找
 *
 */

/*
  1、作用域
   规定变量存、取的规则，编译阶段确定（与运行时无关），ES5只包含函数作用域、全局作用域，ES6+新增了块级作用域
  2、作用域链
   运行时形成的链式存储结构，主要用于访问变量的值，查找时有内向外查找，一直到全局的作用域（如果没有查找的情况下）
  3、执行上下文
    当前函数执行的环境，主要包含this、作用域链、变量对象（VO->AO）
  4、this
    不同调用情况下的this绑定值不同，需要区分修饰符
  5、闭包
    定义：函数内部发生嵌套，内部函数访问了外部函数的变量，内部函数能够在全局作用域中被访问
    具体应用：节流及防抖的实现、模块化实现、三方开源库（redux、koa）等
  6、垃圾回收
     标记清理：从root对象开始遍历所有子节点并完成标记，然后再依次遍历子节点的子节点并完成标记
     未能触达的结点（没有从root对象出发，存在路径可以访问的情况）会被清理掉
  7、内存泄露
    + 闭包内引用了外部变量，导致垃圾回收无法销毁对象，可以将闭包设置为null
    + 声明的变量被挂载到全局对象上了
    + 定时器引用的对象，未清理定时器
    + DOM对象绑定监听但是未清理监听事件
    + 将DOM对象移除，但是未将DOM对象设置为null，内存中仍然可以访问DOM对象
*/

//1、作用域：代码中的成员所起作用的范围
let name = 'li'
const age = 18

/**
 * 2、作用域如何创建的？
 *  理解作用域链创建和使用的细节对理解闭包非常重要
 * 在 调用一个函数时，会为这个函数调用创建一个执行上下文，
 *  并创建一个作用域链。然后用 arguments 和其他命名参数来初始化这个函数的活动对象。
 * 外部函数的活动对象是内部函数作用域链上的第二个对 象。
 * 这个作用域链一直向外串起了所有包含函数的活动对象，直到全局执行上下文才终止。

 * 
*/

// 1、闭包实例
const foo = (function () {
  var v = 0
  return () => {
    return v++
  }
})()

for (let index = 0; index < 10; index++) {
  foo()
}

console.log(foo())

//2、作用域链 : fn是一个隐式闭包
var fn = null

const foo2 = () => {
  var a = 2
  function innerFunc() {
    // console.log(c) //:ReferenceError: c is not defined; innnerFunc的作用域链上没有该变量
    console.log(a)
  }
  fn = innerFunc
}

const bar2 = () => {
  var c = 10
  fn()
}

foo2()
bar2()
