## 1、响应式

### 1.1 响应式原理的基本实现

> - 通过 Proxy 代理对象，拦截对象的读操作（get），使用 track 收集副作用函数（使用桶来存储：weakMap-map-set），拦截对象的写操作（set），使用 trigger 触发副作用函数
> - 组件的 render 函数被通用的 effect 函数注册包裹形成一个副作用函数
> - render 函数执行时会触发对象的读操作，从而收集副作用函数
> - 代理的对象的属性被修改时，会触发副作用函数的执行

### 1.2 watchEffect vs watch

> watchEffect 自动收集依赖，watch 手动收集依赖

## 2、虚拟 DOM 与 diff 算法

> - 双端遍历法
> - 快速 diff：最长递增子序列法

## 3、组件

> 组件由于自身状态发生改变而触发的更新是异步的【通过任务队列（set），Promise 微任务队列】

### 3.1、emit 自定义事件的实现

> 自定义事件都会被挂载到组件的 props 中，使用 emit 函数会根据 eventName 找到对应的 props，然后执行 props 中的回调函数。

### 3.2、setup 函数的实现

> 组件挂载时会执行 setup 函数并传入 props 和 context【emit、attrs、slots 等】，返回一个对象，这个对象会被挂载到组件的实例上。

### 3.3、插槽的的工作原理和实现

> 编译器对于插槽的处理会将插槽的内容编译成一个函数，这个函数会被挂载到组件的实例上，然后在渲染函数中会调用这个函数，将插槽的内容渲染到页面上。

### 4、组件的生命周期

> onMounted: 判断当前组件实例是否存在，如果存在则将注册函数添加到组件实例的 mounted 数组中。在组件挂载后，会依次执行 mounted 数组中的函数。

## 4、内建组件

### 4.1 keep-alive

> LRU 缓存，组件的实现与底层渲染有关系

### 4.2 Teleport

> 打破 DOM 层级的限制，将组建的渲染位置转移到指定的位置

## 5、性能优化

### 5.1 使用懒加载

> import()函数加载组件，实现按需加载，避免一次性加载所有组件，提高页面加载速度。

### 5.2 合理的使用 keep-alive 及属性设置

> 缓存组件实例，避免重复渲染，提高页面性能。

### 5.3 使用虚拟列表

> 只渲染可视区域内的组件，避免一次性渲染大量组件，提高页面性能。

### 5.4 合理使用 computed 和 watch

> 避免在渲染函数中进行大量计算，使用 computed（缓存大的计算量及其懒加载） 和 watch 进行计算和监听，提高页面性能。

### 5.5 合理使用事件委托

> 避免在渲染函数中绑定大量事件，使用事件委托，提高页面性能。

### 5.6 合理使用 v-if 和 v-show

> v-if 会创建和销毁组件，v-show 只会切换组件的 display 属性，提高页面性能。

### 5.7 对于大型数据采用响应式方案

> 对于大型数据采用响应式方案（shadowRef or shadowReactive），避免一次性渲染大量数据，提高页面性能。

### 5.8 css

> 避免嵌套层级过深，及使用 scoped 避免样式的污染

### 5.9 图片懒加载

> 图片懒加载（开源：v-lazy、IntersectionObserver），避免一次性加载大量图片，提高页面性能。

### 5.10 网络请求

> 网络请求（防抖、节流、缓存），避免一次性发送大量请求，提高页面性能。
> 使用适当的缓存机制（localStorage）
> 设置 http 的缓存策略 （强缓存/协商缓存）

### 5.11 webWorker 的使用

> webWorker 创建一个独立的线程，避免大量计算导致主线程的卡顿

## 6、遇到的棘手问题

### 6.1 旧项目的维护及性能问题

> - 开发冷启动慢 ： 升级打包工具，优化三方库的导入方式、去除无用代码、使用 tree shaking 等
> - 巨石应用：根据业务进行拆分，使用微前端框架
> - 抽离组件库、工具包等，建立私服或者通过 npm 包的管理方式，可以规范业务开发
> - 业务开发代码模板，形成统一的规范，提高开发效率
